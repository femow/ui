(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{122:function(e,t,n){"use strict";(function(e){var o=n(0),r=void 0!==e&&e.navigator&&"ReactNative"===e.navigator.product,i="undefined"!=typeof document;t.a=i||r?o.useLayoutEffect:o.useEffect}).call(this,n(23))},154:function(e,t,n){"use strict";n.r(t),n.d(t,"Position",(function(){return s}));var o=n(99),r=n(0);var i=n(122);var a=function(e,t,n){var a,l;"function"==typeof t?(a=t,l=n||{}):l=t||{};var s=l,c=s.threshold,p=s.root,u=s.rootMargin,d=Object(r.useState)(null),b=d[0],m=d[1],h=Object(o.a)(a||m),f=function(e,t){var n=!0,o=Object(r.useRef)();o.current?n=!!(t&&o.current.deps&&function(e,t){if(e.length!==t.length)return!1;for(var n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}(t,o.current.deps)):o.current={deps:t,result:e()};var i=n?o.current:{deps:t,result:e()};return o.current=i,i.result}((function(){return null!==p&&"undefined"!=typeof IntersectionObserver&&new IntersectionObserver(h,{threshold:c,root:p,rootMargin:u})}),[h,p,u,c&&JSON.stringify(c)]);return Object(i.a)((function(){if(e&&f)return f.observe(e),function(){f.unobserve(e)}}),[f,e]),a?void 0:b||[]},l=n(203);let s;function c(e){if(!e||"string"==typeof e)return e;const{top:t=0,right:n=0,bottom:o=0,left:r=0}=e;return`${t}px ${n}px ${o}px ${r}px`}!function(e){e[e.BEFORE=1]="BEFORE",e[e.INSIDE=2]="INSIDE",e[e.AFTER=3]="AFTER"}(s||(s={}));t.default=function(e,t,n={}){const{root:i,rootMargin:p,threshold:u,scrollDirection:d="vertical"}=n,b=Object(o.a)(t),m=Object(r.useRef)(null),h="scrollParent"===i,f=Object(r.useMemo)((()=>e&&h&&Object(l.default)(e,!0)||null),[e,h]);a(e,(([e],t)=>{var n,o;if(!e)return;const[r,i,a]="vertical"===d?["top","bottom","y"]:["left","right","x"],{[a]:l}=e.boundingClientRect,c=(null==(n=e.rootBounds)?void 0:n[r])||0,p=(null==(o=e.rootBounds)?void 0:o[i])||0;let u=s.INSIDE;e.isIntersecting?u=s.INSIDE:l>p?u=s.AFTER:l<c&&(u=s.BEFORE);const h=m.current;h!==u&&(b({position:u,previousPosition:h},e,t),m.current=u)}),{threshold:u,root:"scrollParent"===i?f:i,rootMargin:c(p)})}},203:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return d}));var o=n(153),r=n(123),i=n(124),a=n(103);function l(e){var t="pageXOffset"===e?"scrollLeft":"scrollTop";return function(n,o){var i=Object(r.a)(n);if(void 0===o)return i?i[e]:n[t];i?i.scrollTo(i[e],o):n[t]=o}}var s=l("pageXOffset"),c=l("pageYOffset");function p(e,t){var n=Object(r.a)(e);return n?n.innerHeight:t?e.clientHeight:function(e){var t=Object(a.a)(e),n={top:0,left:0,height:0,width:0},o=t&&t.documentElement;return o&&Object(i.a)(o,e)?(void 0!==e.getBoundingClientRect&&(n=e.getBoundingClientRect()),n={top:n.top+c(o)-(o.clientTop||0),left:n.left+s(o)-(o.clientLeft||0),width:n.width,height:n.height}):n}(e).height}var u=n(143);function d(e,t){var n=Object(o.a)(e,"position"),r="absolute"===n,i=e.ownerDocument;if("fixed"===n)return i||document;for(;(e=e.parentNode)&&!Object(u.a)(e);){var a=r&&"static"===Object(o.a)(e,"position"),l=(Object(o.a)(e,"overflow")||"")+(Object(o.a)(e,"overflow-y")||"")+Object(o.a)(e,"overflow-x");if(!a&&(/(auto|scroll)/.test(l)&&(t||p(e)<e.scrollHeight)))return e}return i||document}},87:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return x})),n.d(t,"metadata",(function(){return E})),n.d(t,"toc",(function(){return N})),n.d(t,"default",(function(){return I}));var o=n(3),r=n(7),i=n(0),a=n.n(i),l=n(96),s=n(98),c=n.n(s),p=n(106);n(107),n(99),n(120),n(121);n(111),n(112);var u=n(122);new WeakMap;var d=n(154);const b=e=>i.createElement("span",{ref:e,style:{fontSize:0}});var m=function(e){let{renderComponent:t=b,onPositionChange:n}=e,o=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["renderComponent","onPositionChange"]);const[r,i]=Object(p.a)();return Object(d.default)(r,n,o),t(i)},h=n(91);const f=60,g={top:-60,right:-60,bottom:-60,left:-60};function v({horizontal:e}){return a.a.createElement("div",{className:Object(h.default)("flex items-center justify-center text-4xl",e&&"min-w-[30%]")},a.a.createElement("span",{style:{lineHeight:"100px"},className:Object(h.default)(e&&"transform -rotate-90")},"\u25bc"))}function y({horizontal:e}){return a.a.createElement("div",{className:Object(h.default)("absolute border-black border-2 inset-0"),style:Object.assign({boxShadow:"0 0 0 60px rgba(0, 0, 0, .4)"},e?{left:"60px",right:"60px"}:{top:"60px",bottom:"60px"})})}function O({margins:e}){const{top:t,bottom:n}=e;return a.a.createElement(a.a.Fragment,null,null!=t&&a.a.createElement("div",{className:"absolute inset-0 z-10 bg-yellow-200 bg-opacity-50",style:{top:`${t<0?f:f-t}px`,bottom:"auto",height:Math.abs(t),right:17}}),null!=n&&a.a.createElement("div",{className:"absolute inset-0 z-10 bg-yellow-200 bg-opacity-50",style:{top:"auto",bottom:`${n<0?f:f-n}px`,height:Math.abs(n),right:17}}))}function w(e){if(!e)return g;const t=Object.assign({},g);return null!=e.top&&(t.top+=e.top),null!=e.bottom&&(t.bottom+=e.bottom),t}var j=function({horizontal:e,scrollIntoView:t,margins:n}){const[o,r]=Object(p.a)(),[l,s]=Object(i.useState)("");return Object(u.a)((()=>{t&&o&&o.querySelector(".docs-example-waypoint").scrollIntoView({block:"center"})}),[o]),a.a.createElement("div",{className:"relative overflow-hidden mb-4"},l&&a.a.createElement("div",{className:Object(h.default)("bg-black bg-opacity-50 text-white p-4 left-1/2 top-1/2 text-center z-10 transform -translate-y-1/2 -translate-x-1/2 absolute w-64")},l),a.a.createElement(y,{horizontal:e}),n&&a.a.createElement(O,{margins:n}),a.a.createElement("div",{ref:r,className:Object(h.default)("flex relative overflow-auto border rounded",!e&&"flex-col"),style:{minHeight:200,maxHeight:400}},a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(m,{root:"scrollParent",rootMargin:w(n),scrollDirection:e?"horizontal":"vertical",renderComponent:t=>a.a.createElement("div",{ref:t,className:Object(h.default)("docs-example-waypoint","border-dashed border-primary",e?"border-l-4":"border-t-4")}),onPositionChange:({position:e})=>{e!==d.Position.BEFORE&&e!==d.Position.AFTER||s(`Exited (${d.Position[e].toLowerCase()})`),e===d.Position.INSIDE&&s("Entered")}}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e}),a.a.createElement(v,{horizontal:e})))},x={},E={unversionedId:"Waypoint",id:"Waypoint",isDocsHomePage:!1,title:"Waypoint",description:"A component (and related hook) to provide a high level interface",source:"@site/docs/Waypoint.mdx",slug:"/Waypoint",permalink:"/ui/Waypoint",version:"current",sidebar:"docs",previous:{title:"Portal",permalink:"/ui/Portal"},next:{title:"usePopper",permalink:"/ui/usePopper"}},N=[{value:"How it works",id:"how-it-works",children:[]},{value:"Scroll direction",id:"scroll-direction",children:[]},{value:"Specifying the scroll parent",id:"specifying-the-scroll-parent",children:[]},{value:"Margins",id:"margins",children:[]},{value:"<code>useWaypoint</code>",id:"usewaypoint",children:[]}],z={toc:N};function I(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(o.a)({},z,i,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"A component (and related hook) to provide a high level interface\nover ",Object(l.b)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"},Object(l.b)("inlineCode",{parentName:"a"},"IntersectionObserver")),"\ndesigned to detect when a component enters and exits a viewport."),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Waypoint"),' provides a good basis for building other components like infinite lists,\n"scroll spy" style navigation, lazy loading images, and more.'),Object(l.b)("h2",{id:"how-it-works"},"How it works"),Object(l.b)("p",null,'Waypoint renders a "sentinel" element that you place in a scrollable\narea. Using an ',Object(l.b)("inlineCode",{parentName:"p"},"IntersectionObserver"),', the waypoint fires a callback when it\n"intersects" with the visible area of the scroll view. Waypoint will fire a callback\nwhen this happens with details about where the waypoint is in relation to the visible\narea.'),Object(l.b)("p",null,"The example below adds visible styling to waypoint for clarity. By default a\nwaypoint renders an invisible zero-height element."),Object(l.b)(j,{scrollIntoView:!0,mdxType:"WaypointExample"}),Object(l.b)("h2",{id:"scroll-direction"},"Scroll direction"),Object(l.b)("p",null,'For simplicity, scroll detection with waypoints is limited to a single direction at one time.\nBy default that direction is "vertical", but can configured to "horizontal".'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-tsx"},'<Waypoint scrollDirection="horizontal" />\n')),Object(l.b)(j,{horizontal:!0,mdxType:"WaypointExample"}),Object(l.b)("h2",{id:"specifying-the-scroll-parent"},"Specifying the scroll parent"),Object(l.b)("p",null,"By default waypoint observes scrolling on the device viewport, generally the ",Object(l.b)("inlineCode",{parentName:"p"},"window"),".\nYou can also specify a specific element as the root by providing a DOM element\nto the ",Object(l.b)("inlineCode",{parentName:"p"},"root")," prop."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-tsx"},'function ScrollArea({ items, onPositionChange }) {\n  const [element, setElement] = useState<HTMLDivElement>(\n    null\n  );\n\n  return (\n    <div ref={setElement} style={{ overflow: "auto" }}>\n      {items}\n      <Waypoint\n        root={element}\n        onPositionChange={onPositionChange}\n      />\n    </div>\n  );\n}\n')),Object(l.b)("h2",{id:"margins"},"Margins"),Object(l.b)("p",null,"You can adjust the functional shape of the viewport by providing a ",Object(l.b)("inlineCode",{parentName:"p"},"rootMargin"),"\nprop, which is passed to the underlying ",Object(l.b)("inlineCode",{parentName:"p"},"IntersectionObserver"),". As a convenience,\nWaypoint accepts an object with inset properties as well as a valid CSS margin property\nvalue."),Object(l.b)("p",null,"Positive margins grow the overall size of the viewport causing waypoints to enter\nbefore they are actually in view. Negative values shrink the viewport, and delays\nthe waypoint from entering by the specified pixel amount. Margins are illustrated\nby the yellow blocks in the example below."),Object(l.b)("p",null,"Here is an example of positive margins:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-tsx"},"<Waypoint rootMargin={{ top: 20, bottom: 20 }} />\n")),Object(l.b)(j,{margins:{top:20,bottom:20},mdxType:"WaypointExample"}),Object(l.b)("p",null,"And the effect with negative margins"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-tsx"},"<Waypoint rootMargin={{ top: -20, bottom: -20 }} />\n")),Object(l.b)(j,{margins:{top:-20,bottom:-20},mdxType:"WaypointExample"}),Object(l.b)("h2",{id:"usewaypoint"},Object(l.b)("inlineCode",{parentName:"h2"},"useWaypoint")),Object(l.b)("p",null,"The underlying hook powering the Waypoint component. Leverage ",Object(l.b)("inlineCode",{parentName:"p"},"useWaypoint"),"\nto turn any component into a waypoint. Using the hook directly is helpful\nwhen you want an individual component to respond"),Object(l.b)(c.a,{imports:function(){return Object(s.allValues)({"dom-helpers/scrollParent":Promise.resolve().then(n.bind(null,203)),"@restart/ui/useWaypoint":Promise.resolve().then(n.bind(null,154))})},mdxType:"ImportContext"},Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-tsx",metastring:"live",live:!0},'import getScrollParent from "dom-helpers/scrollParent";\nimport useWaypoint, {\n  Position,\n} from "@restart/ui/useWaypoint";\n\nfunction LazyImage({ src }) {\n  const [element, attachRef] = useState(null);\n  const [hasBeenSeen, setSeen] = useState(false);\n\n  const waypointRef = useWaypoint(\n    element,\n    ({ position, previousPosition }, entry, observer) => {\n      if (hasBeenSeen) {\n        return;\n      }\n\n      setSeen(position === Position.INSIDE);\n    },\n    {\n      root: "scrollParent",\n      scrollDirection: "horizontal",\n      rootMargin: { right: -80 },\n    }\n  );\n\n  return (\n    <img\n      ref={attachRef}\n      style={{\n        height: 160,\n        width: 160,\n        display: "inline-block",\n      }}\n      // swap out for the real image when it\'s been seen\n      src={hasBeenSeen ? src : ""}\n    />\n  );\n}\n\n<div className="relative py-4">\n  <div\n    className="absolute border-black border-2 pointer-events-none "\n    style={{ top: 0, bottom: 40, left: 0, right: 80 }}\n  />\n  <div className="overflow-x-scroll h-56 grid grid-flow-col auto-cols-[160px]">\n    <LazyImage src="https://picsum.photos/id/237/160/160" />\n    <LazyImage src="https://picsum.photos/id/153/160/160" />\n    <LazyImage src="https://picsum.photos/id/125/160/160" />\n    <LazyImage src="https://picsum.photos/id/74/160/160" />\n    <LazyImage src="https://picsum.photos/id/50/160/160" />\n    <LazyImage src="https://picsum.photos/id/34/160/160" />\n    <LazyImage src="https://picsum.photos/id/12/160/160" />\n    <LazyImage src="https://picsum.photos/id/64/160/160" />\n    <LazyImage src="https://picsum.photos/id/18/160/160" />\n  </div>\n</div>;\n'))))}I.isMDXComponent=!0}}]);